<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>递归函数</title>
</head>
<body>
<script type="text/javascript">
	// 递归：根据已知条件 推导结果
	//找规律 ()中也应该是几？  第100个数（从0开始计数）是多少？  0-n的所有数的和
	//n     0 1 2 3 4  5  6  7  8  9     10
	//f1(n) 0 1 3 6 10 15 21 28 36 (45)  55 
	// 0
	// 0 + 1 = 1
	// 1 + 2 = 3
	// 3 + 3 = 6
	// 6 + 4 = 10
	// 10 + 5
	// //m n 表示连续的两个数字
	// an =  am+ n;  a0 = 0;
	// f1(n) = f1(n-1) + n;  特殊情况 n =0 
	/*function f1(n){
		if(n == 0){
			return 0;
		}else{
			return n + f1(n-1);
		}
	}
	// n = 0; f1(0) = 0;  f1(1) = f1(0) + 1;  f1(2) = f1(1) + 2...
	// f1(n) = n + f1(n-1);
	// f1(n) = n + (n-1 + f1(n-2))  ...... f1(0)
	console.log( f1(0) );
	console.log( f1(1) );
	console.log( f1(2) );
	console.log( f1(3) );
	console.log( f1(4) );
	console.log( f1(5) );
	console.log( f1(6) );
	console.log( f1(7) );
	console.log( f1(8) );

	console.log( f1(9) );
	console.log( f1(100) );*/
	//以上函数（递归函数）的特点：函数自己调用自己、有结束判断条件（递归出口）
	//递归层数不能太深
	//z    0 1 2 3 4  5  6  7  8   9
	//f(z) 0 1 1 2 3  5  8  13 21 (34)
	// 0
	// 1
	// 0 + 1 = 1
	// 1 + 1 = 2
	// 1 + 2 = 3
	// 2 + 3 = 5
	// 。。。。。。
	// f(9) = f(8) + f(7);
	// f(9) = f(7) + f(6) + f(6) + f(5);  f(2) = f(1) + f(0);
	// ......
	// f(9) = 34个f(1) + 很多个f(0)
	// x y z 连续的数字
	// az = ay + ax; // 递归方程
	// 假设函数f，返回的是第z个值
	// f(z) = f(z-1) + f(z-2);  
	// 已知 f(0) = 0;  f(1) = 1
	function f(z){
		if(z <= 1){
			return z;
		}else{
			return f(z-1) + f(z-2);
		}
	}
	console.log(f(0));
	console.log(f(1));
	console.log(f(2));
	console.log(f(3));
	console.log(f(4));
	console.log(f(5));
	console.log(f(6));
	console.log(f(7));
	console.log(f(8));
	console.log(f(9));
	console.log(f(40));
	// console.log(f(100));//数据太大，递归次数太多，会导致内存占用过高。
</script> 
</body>
</html>